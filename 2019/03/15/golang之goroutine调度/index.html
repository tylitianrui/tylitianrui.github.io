<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  
  <title>golang之goroutine调度 | tyltr技术窝</title>
  
  

  

  <meta name="HandheldFriendly" content="True">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!-- meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.10.1/css/all.min.css">
  

  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.9.9/css/style.css">
  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
</head>

<body>
  
  
  <div class="cover-wrapper">
    <cover class='cover post half'>
      
        
  <h1 class='title'>tyltr技术窝</h1>


<div class='menu navgation'>
  <ul class='h-list'>
    
  </ul>
</div>

      
    </cover>
    <header class="l_header pure">
  <div id="loading-bar-wrapper">
    <div id="loading-bar" class="pure"></div>
  </div>

	<div class='wrapper'>
		<div class="nav-main container container--flex">
      <a class="logo flat-box" href='/' >
        
          tyltr技术窝
        
      </a>
			<div class='menu navgation'>
				<ul class='h-list'>
          
  					
  						<li>
								<a class="nav flat-box" href="/"
                  
                  
                  id="home">
									<i class='fas fa-grin fa-fw'></i>&nbsp;示例
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/archives"
                  
                    rel="nofollow"
                  
                  
                  id="archives">
									<i class='fas fa-archive fa-fw'></i>&nbsp;归档
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/about"
                  
                    rel="nofollow"
                  
                  
                  id="about">
									<i class='fas fa-archive fa-fw'></i>&nbsp;关于
								</a>
							</li>
      			
      		
				</ul>
			</div>

			
			<ul class='switcher h-list'>
				
				<li class='s-menu'><a class="fas fa-bars fa-fw" href='javascript:void(0)'></a></li>
			</ul>
		</div>

		<div class='nav-sub container container--flex'>
			<a class="logo flat-box"></a>
			<ul class='switcher h-list'>
				<li class='s-comment'><a class="flat-btn fas fa-comments fa-fw" href='javascript:void(0)'></a></li>
        
          <li class='s-toc'><a class="flat-btn fas fa-list fa-fw" href='javascript:void(0)'></a></li>
        
			</ul>
		</div>
	</div>
</header>
	<aside class="menu-phone">
    <header>
		<nav class="menu navgation">
      <ul>
        
          
            <li>
							<a class="nav flat-box" href="/"
                
                
                id="home">
								<i class='fas fa-clock fa-fw'></i>&nbsp;近期文章
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/archives"
                
                  rel="nofollow"
                
                
                id="archives">
								<i class='fas fa-archive fa-fw'></i>&nbsp;文章归档
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/about/"
                
                  rel="nofollow"
                
                
                id="about">
								<i class='fas fa-info-circle fa-fw'></i>&nbsp;关于我
							</a>
            </li>
          
       
      </ul>
		</nav>
    </header>
	</aside>
<script>setLoadingBarProgress(40);</script>

  </div>


  <div class="l_body">
    <div class='body-wrapper'>
      <div class='l_main'>
  

  <article id="post" class="post white-box article-type-post" itemscope itemprop="blogPost">
    


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  
    <h1 class="title">
      <a href="/2019/03/15/golang之goroutine调度/">
        golang之goroutine调度
      </a>
    </h1>
  


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://sudozoyo.com" rel="nofollow">
        
          <i class="fas fa-user" aria-hidden="true"></i>
        
        <p>tylitianrui</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-03-15</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/golang/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>golang</p>
    </a>
  </div>


          
        
          
            
  
    <div class="new-meta-item browse busuanzi">
      <a class='notlink'>
        <i class="fas fa-eye" aria-hidden="true"></i>
        <p>
          <span id="busuanzi_value_page_pv">
            <i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i>
          </span>
        </p>
      </a>
    </div>
  


          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


    <section class="article typo">
      <div class="article-entry" itemprop="articleBody">
        <p>goroutine 是<code>golang</code>的一大特色，用户级别的轻量级线程。它是怎么调度的呢？本文主要讲述 <code>goroutine</code>的调度。</p>
<h2><span id="1-diao-du-mo-xing">1.调度模型</span><a href="#1-diao-du-mo-xing" class="header-anchor">#</a></h2><p>现在主流的线程模型分三种：<strong>内核级线程模型</strong>、<strong>用户级线程模型</strong>和<strong>两级线程模型</strong>（有的文档也称为混合型线程模型)。它们之间根本的区别就在于：线程与内核调度实体的对应关系。  </p>
<h3><span id="1-1-nei-he-ji-xian-cheng-mo-xing">1.1 内核级线程模型</span><a href="#1-1-nei-he-ji-xian-cheng-mo-xing" class="header-anchor">#</a></h3><p>就是把所有的用户线程绑定到一个内核线程上(N:1的关系)。什么时候创建、终止、调度都是基于内核提供的系统调用。也就是说，<strong>完全靠操作系统调度</strong> 。  </p>
<p>这种调度模型，因为在所有用户线程映射到同一个内核线程上，所有上下文的切换低，但不能充分利用多核资源了。</p>
<h3><span id="1-2-yong-hu-ji-xian-cheng-mo-xing">1.2 用户级线程模型</span><a href="#1-2-yong-hu-ji-xian-cheng-mo-xing" class="header-anchor">#</a></h3><p>每一个线程对应一个内核线程(1:1关系)。充分利用多核资源，上下文切换成本较高。</p>
<h3><span id="1-3-liang-ji-xian-cheng-mo-xing">1.3 两级线程模型</span><a href="#1-3-liang-ji-xian-cheng-mo-xing" class="header-anchor">#</a></h3><p>因为上面两种调度模型，都有各自的优劣点。对上面两种进行权衡，实现了(M:N)两级线程模型。既充分利用了内核资源，又尽可能的减少上下文切换的开销。<code>goroutine</code>就是采用的这种调度模型。这里的M:N 指的是M个 <code>goroutine</code> 运行在N个操作系统线程之上。内核负责这 N个操作系统线程的调度，这N个线程负责M个 <code>goroutine</code> 的调度与运行。</p>
<h2><span id="2-mpg-mo-xing">2.MPG模型</span><a href="#2-mpg-mo-xing" class="header-anchor">#</a></h2><h3><span id="2-1-jian-shu">2.1 简述</span><a href="#2-1-jian-shu" class="header-anchor">#</a></h3><p>有上文可知，M个 <code>goroutine</code> 的调度也是M:N模型。那么<code>goroutine</code>是如何调度的呢？所谓的对<code>goroutine</code>的调度，是指程序代码按照一定的算法在适当的时候挑选出合适的<code>goroutine</code>并放到<code>CPU</code>上去运行的过程，这些负责对goroutine进行调度的程序代码我们称之为<strong><code>goroutine</code>调度器</strong>。  </p>
<p>由上面的简述可以知道，<code>goroutine</code>调度器会挑选适合的<code>goroutine</code>运行，那么从哪里去挑选<code>goroutine</code>呢？在切换的过程中状态信息又保存在哪里呢？带着这两个问题我们继续下面的内容。  </p>
<p><code>goroutine</code>的调度实际就是通过保存和修改<code>CPU</code>寄存器的值到达切换线程/goroutine的目的（话外语：<em>简要概述起来运行在CPU上的线程，本质上就是把自己的状态信息放到了CPU寄存器上了。cpu上下文的切换的本质就是把旧线程在CPU寄存器的状态信息存入内存对应的寄存器中，把新线程保存在内存之中的寄存器的值放入CPU寄存器从而恢复新线程的运行</em>）   </p>
<p>万变不离其宗，要想实现对<code>goroutine</code>的调度，就必须有一个保存<code>CPU</code>寄存器的值以及<code>goroutine</code>的状态信息的对象。这个对象（或者成为数据结构）就是GO语言中的<strong>G结构体</strong>,也就是<code>MPG</code>模型中的<code>G</code>。它保存着所有<code>goroutine</code>的状态信息，该结构体每个实例都代表一个<code>goroutine</code>。调度器通过g对象实现对<code>goroutine</code>的调度。当<code>goroutine</code>调离<code>CPU</code>时，调度器会把<code>CPU</code>寄存器的值保存到g对象的变量中；当<code>goroutine</code>被调度运行的时候，调度器会把<code>CPU</code>会把g对象的变量中值恢复到<code>CPU</code>寄存器中。  </p>
<p>由上可以看出，G是<code>goroutine</code>的抽象。那么仅仅有这个抽象就可以完成<code>goroutine</code>的调度吗?显然不够，还记得我们的问题吗？( <em><code>goroutine</code>调度器会挑选适合的<code>goroutine</code>运行，那么从哪里去挑选<code>goroutine</code>呢?</em> )。所以我们需要一个存放所有(或者可运行状态)的<code>goroutine</code>的容器，以便调度器寻找到可运行状态的<code>goroutine</code>，于是GO调度器引入的<strong>schedt结构体</strong>。  </p>
<p><strong>schedt结构体</strong>既保存调度器自身的状态信息，又拥有一个保存<code>goroutine</code>的运行队列。因为每一个go程序只有一个调度器，而且在每一个go程序中，<strong>schedt结构体</strong>也只有一个实例对象。这个实例对象在源码中被定义为一个共享的<strong>全局变量</strong>，所以每一个工作线程都可以访问到它和它所拥有的<code>goroutine</code>的运行队列,因此这个运行队列被称为<strong>全局运行队列</strong>。  </p>
<p>根据上面讲述，我们可以初步地得到答案：G是<code>goroutine</code>的抽象，保存中<code>goroutine</code>的全部信息。每个Go程序中有且只有一个共享的<strong>全局运行队列</strong>保存可运行的<code>goroutine</code>(也可以说是全局队列中保存着可运行状态G)。  </p>
<p>说到<strong>全局运行队列</strong>，那有没有<strong>局部运行队列</strong>呢？如果您有这种猜想，那说明您才思敏捷。每个工作线程中确实有一个私有的<strong>局部<code>goroutine</code>运行队列</strong>。那为啥有了<strong>全局运行队列</strong>还要有<strong>局部运行队列</strong>呢？这么说吧。<strong>既然是共享，也就意味着锁的存在</strong>，加锁势必会影响性能。如果每个工作线程有了各自私有的<strong>局部<code>goroutine</code>运行队列</strong>，那么就会避免的锁的问题，提升性能。工作线程优先在全局运行队列选取<code>goroutine</code>进行运行，但只有<code>1/61</code>的概率；如果没有获取到，再去自己的本地可运行列表中获取g。在Go调度器源代码中，局部运行队列被包含在<strong>p结构体</strong>的实例对象之中，每一个运行着go代码的工作线程都会与一个p结构体的实例对象关联在一起。  </p>
<p><code>MPG</code>模型中，<code>P</code>、<code>G</code>都逐渐漏出庐山真面目了，那么<code>M</code>又是什么鬼？那你注意到上文中一直提到的‘工作线程’了吗？</p>
<p>Go调度器源代码中，<strong>M结构体</strong>就代表工作线程，每个工作线程都有唯一的一个M结构体的实例对象与之对应，M结构体对象除了记录着工作线程的诸如栈的起止位置、当前正在执行的goroutine以及是否空闲等等状态信息之外，还通过指针维持着与P结构体的实例对象之间的绑定关系。那么直奔主题吧。  </p>
<p><img src="http://pzklm3h5m.bkt.clouddn.com/12wert654ewsxcgy78kgwtgfrewsft67urewsxcddfthgf.png" alt="MPG模型"></p>
<ul>
<li>M: 一个M直接关联了一个内核线程</li>
<li>P: 代表了M所需的上下文环境，也是处理用户级代码逻辑的处理器。</li>
<li>G: goroutine的抽象 </li>
</ul>
<h3><span id="2-2-yuan-ma-fen-xi">2.2 源码分析</span><a href="#2-2-yuan-ma-fen-xi" class="header-anchor">#</a></h3><p>上面我们把<code>M</code>、<code>P</code>、<code>G</code>等概念粗略的说了一遍。但<code>M</code>、<code>P</code>、<code>G</code>具体是什么鬼呢？那么咱们分析一下源码，源码文件<code>runtime/runtime2.go</code>。  </p>
<h4><span id="2-2-1-g-jie-gou-ti">2.2.1 g结构体</span><a href="#2-2-1-g-jie-gou-ti" class="header-anchor">#</a></h4><p>g结构体用于代表一个goroutine，该结构体保存了goroutine的所有信息，包括栈，gobuf结构体和其它的一些状态信息。下面看一下g的定义。因为g都会被放入调度队列之中，所以每个g中都有一个指向下一个g的指针。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> g <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Stack parameters.</span></span><br><span class="line">	<span class="comment">// stack describes the actual stack memory: [stack.lo, stack.hi).</span></span><br><span class="line">	<span class="comment">// stackguard0 is the stack pointer compared in the Go stack growth prologue.</span></span><br><span class="line">	<span class="comment">// It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption.</span></span><br><span class="line">	<span class="comment">// stackguard1 is the stack pointer compared in the C stack growth prologue.</span></span><br><span class="line">	<span class="comment">// It is stack.lo+StackGuard on g0 and gsignal stacks.</span></span><br><span class="line">    <span class="comment">// It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash).</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录该goroutine使用的栈</span></span><br><span class="line">    stack       stack   <span class="comment">// offset known to runtime/cgo</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 下面两个成员用于栈溢出检查，实现栈的自动伸缩，抢占调度也会用到stackguard0</span></span><br><span class="line">	stackguard0 <span class="keyword">uintptr</span> <span class="comment">// offset known to liblink</span></span><br><span class="line">	stackguard1 <span class="keyword">uintptr</span> <span class="comment">// offset known to liblink</span></span><br><span class="line"></span><br><span class="line">	_panic         *_panic <span class="comment">// innermost panic - offset known to liblink</span></span><br><span class="line">    _defer         *_defer <span class="comment">// innermost defer</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此goroutine正在被哪个工作线程执行</span></span><br><span class="line">    m              *m      <span class="comment">// current m; offset known to arm liblink</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存调度信息，主要是几个寄存器的值</span></span><br><span class="line">    sched          gobuf</span><br><span class="line">    </span><br><span class="line">	syscallsp      <span class="keyword">uintptr</span>        <span class="comment">// if status==Gsyscall, syscallsp = sched.sp to use during gc</span></span><br><span class="line">	syscallpc      <span class="keyword">uintptr</span>        <span class="comment">// if status==Gsyscall, syscallpc = sched.pc to use during gc</span></span><br><span class="line">	stktopsp       <span class="keyword">uintptr</span>        <span class="comment">// expected sp at top of stack, to check in traceback</span></span><br><span class="line">	param          unsafe.Pointer <span class="comment">// passed parameter on wakeup</span></span><br><span class="line">	atomicstatus   <span class="keyword">uint32</span></span><br><span class="line">	stackLock      <span class="keyword">uint32</span> <span class="comment">// sigprof/scang lock; <span class="doctag">TODO:</span> fold in to atomicstatus</span></span><br><span class="line">    goid           <span class="keyword">int64</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// schedlink字段指向全局运行队列中的下一个g，</span></span><br><span class="line">    <span class="comment">// 所有位于全局运行队列中的g形成一个链表</span></span><br><span class="line">    schedlink      guintptr</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">	waitsince      <span class="keyword">int64</span>      <span class="comment">// approx time when the g become blocked</span></span><br><span class="line">	waitreason     waitReason <span class="comment">// if status==Gwaiting</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 抢占调度标志，如果需要抢占调度，设置preempt为true</span></span><br><span class="line">    preempt        <span class="keyword">bool</span>       <span class="comment">// preemption signal, duplicates stackguard0 = stackpreempt</span></span><br><span class="line">    </span><br><span class="line">    paniconfault   <span class="keyword">bool</span>       <span class="comment">// panic (instead of crash) on unexpected fault address</span></span><br><span class="line">	preemptscan    <span class="keyword">bool</span>       <span class="comment">// preempted g does scan for gc</span></span><br><span class="line">	gcscandone     <span class="keyword">bool</span>       <span class="comment">// g has scanned stack; protected by _Gscan bit in status</span></span><br><span class="line">	gcscanvalid    <span class="keyword">bool</span>       <span class="comment">// false at start of gc cycle, true if G has not run since last scan; <span class="doctag">TODO:</span> remove?</span></span><br><span class="line">	throwsplit     <span class="keyword">bool</span>       <span class="comment">// must not split stack</span></span><br><span class="line">	raceignore     <span class="keyword">int8</span>       <span class="comment">// ignore race detection events</span></span><br><span class="line">	sysblocktraced <span class="keyword">bool</span>       <span class="comment">// StartTrace has emitted EvGoInSyscall about this goroutine</span></span><br><span class="line">	sysexitticks   <span class="keyword">int64</span>      <span class="comment">// cputicks when syscall has returned (for tracing)</span></span><br><span class="line">	traceseq       <span class="keyword">uint64</span>     <span class="comment">// trace event sequencer</span></span><br><span class="line">	tracelastp     puintptr   <span class="comment">// last P emitted an event for this goroutine</span></span><br><span class="line">	lockedm        muintptr</span><br><span class="line">	sig            <span class="keyword">uint32</span></span><br><span class="line">	writebuf       []<span class="keyword">byte</span></span><br><span class="line">	sigcode0       <span class="keyword">uintptr</span></span><br><span class="line">	sigcode1       <span class="keyword">uintptr</span></span><br><span class="line">	sigpc          <span class="keyword">uintptr</span></span><br><span class="line">	gopc           <span class="keyword">uintptr</span>         <span class="comment">// pc of go statement that created this goroutine</span></span><br><span class="line">	ancestors      *[]ancestorInfo <span class="comment">// ancestor information goroutine(s) that created this goroutine (only used if debug.tracebackancestors)</span></span><br><span class="line">	startpc        <span class="keyword">uintptr</span>         <span class="comment">// pc of goroutine function</span></span><br><span class="line">	racectx        <span class="keyword">uintptr</span></span><br><span class="line">	waiting        *sudog         <span class="comment">// sudog structures this g is waiting on (that have a valid elem ptr); in lock order</span></span><br><span class="line">	cgoCtxt        []<span class="keyword">uintptr</span>      <span class="comment">// cgo traceback context</span></span><br><span class="line">	labels         unsafe.Pointer <span class="comment">// profiler labels</span></span><br><span class="line">	timer          *timer         <span class="comment">// cached timer for time.Sleep</span></span><br><span class="line">	selectDone     <span class="keyword">uint32</span>         <span class="comment">// are we participating in a select and did someone win the race?</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Per-G GC state</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// gcAssistBytes is this G's GC assist credit in terms of</span></span><br><span class="line">	<span class="comment">// bytes allocated. If this is positive, then the G has credit</span></span><br><span class="line">	<span class="comment">// to allocate gcAssistBytes bytes without assisting. If this</span></span><br><span class="line">	<span class="comment">// is negative, then the G must correct this by performing</span></span><br><span class="line">	<span class="comment">// scan work. We track this in bytes to make it fast to update</span></span><br><span class="line">	<span class="comment">// and check for debt in the malloc hot path. The assist ratio</span></span><br><span class="line">	<span class="comment">// determines how this corresponds to scan work debt.</span></span><br><span class="line">	gcAssistBytes <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面源码里，定义了<code>stack</code>类型的数据，那么<code>stack</code> 是什么鬼？<br>stack结构体主要用来记录goroutine所使用的栈的信息，包括栈顶和栈底位置  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stack describes a Go execution stack.</span></span><br><span class="line"><span class="comment">// The bounds of the stack are exactly [lo, hi),</span></span><br><span class="line"><span class="comment">// with no implicit data structures on either side.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用于记录goroutine使用的栈的起始和结束位置</span></span><br><span class="line"><span class="keyword">type</span> stack <span class="keyword">struct</span> &#123;  </span><br><span class="line">    lo <span class="keyword">uintptr</span>   <span class="comment">// 栈顶，指向内存低地址</span></span><br><span class="line">    hi <span class="keyword">uintptr</span>   <span class="comment">// 栈底，指向内存高地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="2-2-2-m-jie-gou-ti">2.2.2 m结构体</span><a href="#2-2-2-m-jie-gou-ti" class="header-anchor">#</a></h4><p>m结构体用来代表工作线程，它保存了m自身使用的栈信息，当前正在运行的goroutine以及与m绑定的p等信息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> m <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="comment">// g0主要用来记录工作线程使用的栈信息，在执行调度代码时需要使用这个栈</span></span><br><span class="line">    <span class="comment">// 执行用户goroutine代码时，使用用户goroutine自己的栈，调度时会发生栈的切换</span></span><br><span class="line">    g0     *g    <span class="comment">// goroutine with scheduling stack</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过TLS实现m结构体对象与工作线程之间的绑定</span></span><br><span class="line">    tls             [<span class="number">6</span>]<span class="keyword">uintptr</span>  <span class="comment">// thread-local storage (for x86 extern register)</span></span><br><span class="line">    mstartfn    <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    // 指向工作线程正在运行的<span class="title">goroutine</span>的<span class="title">g</span>结构体对象</span></span><br><span class="line"><span class="function">    <span class="title">curg</span>         *<span class="title">g</span>      // <span class="title">current</span> <span class="title">running</span> <span class="title">goroutine</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    // 记录与当前工作线程绑定的<span class="title">p</span>结构体对象</span></span><br><span class="line"><span class="function">    <span class="title">p</span>            <span class="title">puintptr</span>// <span class="title">attached</span> <span class="title">p</span> <span class="title">for</span> <span class="title">executing</span> <span class="title">go</span> <span class="title">code</span> <span class="params">(<span class="literal">nil</span> <span class="keyword">if</span> not executing <span class="keyword">go</span> code)</span></span></span><br><span class="line"><span class="function">    <span class="title">nextp</span>      <span class="title">puintptr</span></span></span><br><span class="line"><span class="function">    <span class="title">oldp</span>        <span class="title">puintptr</span>// <span class="title">the</span> <span class="title">p</span> <span class="title">that</span> <span class="title">was</span> <span class="title">attached</span> <span class="title">before</span> <span class="title">executing</span> <span class="title">a</span> <span class="title">syscall</span></span></span><br><span class="line"><span class="function">   </span></span><br><span class="line"><span class="function">    // <span class="title">spinning</span>状态：表示当前工作线程正在试图从其它工作线程的本地运行队列偷取<span class="title">goroutine</span></span></span><br><span class="line"><span class="function">    <span class="title">spinning</span>     <span class="title">bool</span>// <span class="title">m</span> <span class="title">is</span> <span class="title">out</span> <span class="title">of</span> <span class="title">work</span> <span class="title">and</span> <span class="title">is</span> <span class="title">actively</span> <span class="title">looking</span> <span class="title">for</span> <span class="title">work</span></span></span><br><span class="line"><span class="function">    <span class="title">blocked</span>      <span class="title">bool</span>// <span class="title">m</span> <span class="title">is</span> <span class="title">blocked</span> <span class="title">on</span> <span class="title">a</span> <span class="title">note</span></span></span><br><span class="line"><span class="function">   </span></span><br><span class="line"><span class="function">    // 没有<span class="title">goroutine</span>需要运行时，工作线程睡眠在这个<span class="title">park</span>成员上，</span></span><br><span class="line"><span class="function">    // 其它线程通过这个<span class="title">park</span>唤醒该工作线程</span></span><br><span class="line"><span class="function">    <span class="title">park</span>         <span class="title">note</span></span></span><br><span class="line"><span class="function">    // 记录所有工作线程的一个链表</span></span><br><span class="line"><span class="function">    <span class="title">alllink</span>      *<span class="title">m</span>// <span class="title">on</span> <span class="title">allm</span></span></span><br><span class="line"><span class="function">    <span class="title">schedlink</span>    <span class="title">muintptr</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    // <span class="title">Linux</span>平台<span class="title">thread</span>的值就是操作系统线程<span class="title">ID</span></span></span><br><span class="line"><span class="function">    <span class="title">thread</span>       <span class="title">uintptr</span>// <span class="title">thread</span> <span class="title">handle</span></span></span><br><span class="line"><span class="function">    <span class="title">freelink</span>     *<span class="title">m</span>     // <span class="title">on</span> <span class="title">sched</span>.<span class="title">freem</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    ......</span></span><br></pre></td></tr></table></figure>

<h4><span id="2-2-3-p-jie-gou-ti">2.2.3 p结构体</span><a href="#2-2-3-p-jie-gou-ti" class="header-anchor">#</a></h4><p>p结构体用于保存工作线程执行go代码时所必需的资源，比如goroutine的运行队列，内存分配用到的缓存等等</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> p <span class="keyword">struct</span> &#123;</span><br><span class="line">	id          <span class="keyword">int32</span></span><br><span class="line">	status      <span class="keyword">uint32</span> <span class="comment">// one of pidle/prunning/...</span></span><br><span class="line">	link        puintptr</span><br><span class="line">	schedtick   <span class="keyword">uint32</span>     <span class="comment">// incremented on every scheduler call</span></span><br><span class="line">	syscalltick <span class="keyword">uint32</span>     <span class="comment">// incremented on every system call</span></span><br><span class="line">	sysmontick  sysmontick <span class="comment">// last tick observed by sysmon</span></span><br><span class="line">	m           muintptr   <span class="comment">// back-link to associated m (nil if idle)</span></span><br><span class="line">	mcache      *mcache</span><br><span class="line">	raceprocctx <span class="keyword">uintptr</span></span><br><span class="line"></span><br><span class="line">	deferpool    [<span class="number">5</span>][]*_defer <span class="comment">// pool of available defer structs of different sizes (see panic.go)</span></span><br><span class="line">	deferpoolbuf [<span class="number">5</span>][<span class="number">32</span>]*_defer</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Cache of goroutine ids, amortizes accesses to runtime·sched.goidgen.</span></span><br><span class="line">	goidcache    <span class="keyword">uint64</span></span><br><span class="line">	goidcacheend <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Queue of runnable goroutines. Accessed without lock.</span></span><br><span class="line">    <span class="comment">// 本地goroutine运行队列</span></span><br><span class="line">	runqhead <span class="keyword">uint32</span>   <span class="comment">// 列表头</span></span><br><span class="line">	runqtail <span class="keyword">uint32</span>   <span class="comment">// 列表尾</span></span><br><span class="line">	runq     [<span class="number">256</span>]guintptr  <span class="comment">//使用数组实现的循环队列</span></span><br><span class="line">	<span class="comment">// runnext, if non-nil, is a runnable G that was ready'd by</span></span><br><span class="line">	<span class="comment">// the current G and should be run next instead of what's in</span></span><br><span class="line">	<span class="comment">// runq if there's time remaining in the running G's time</span></span><br><span class="line">	<span class="comment">// slice. It will inherit the time left in the current time</span></span><br><span class="line">	<span class="comment">// slice. If a set of goroutines is locked in a</span></span><br><span class="line">	<span class="comment">// communicate-and-wait pattern, this schedules that set as a</span></span><br><span class="line">	<span class="comment">// unit and eliminates the (potentially large) scheduling</span></span><br><span class="line">	<span class="comment">// latency that otherwise arises from adding the ready'd</span></span><br><span class="line">	<span class="comment">// goroutines to the end of the run queue.</span></span><br><span class="line">	runnext guintptr</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Available G's (status == Gdead)</span></span><br><span class="line">	gFree <span class="keyword">struct</span> &#123;</span><br><span class="line">		gList</span><br><span class="line">		n <span class="keyword">int32</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sudogcache []*sudog</span><br><span class="line">	sudogbuf   [<span class="number">128</span>]*sudog</span><br><span class="line"></span><br><span class="line">	tracebuf traceBufPtr</span><br><span class="line"></span><br><span class="line">	<span class="comment">// traceSweep indicates the sweep events should be traced.</span></span><br><span class="line">	<span class="comment">// This is used to defer the sweep start event until a span</span></span><br><span class="line">	<span class="comment">// has actually been swept.</span></span><br><span class="line">	traceSweep <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// traceSwept and traceReclaimed track the number of bytes</span></span><br><span class="line">	<span class="comment">// swept and reclaimed by sweeping in the current sweep loop.</span></span><br><span class="line">	traceSwept, traceReclaimed <span class="keyword">uintptr</span></span><br><span class="line"></span><br><span class="line">	palloc persistentAlloc <span class="comment">// per-P to avoid mutex</span></span><br><span class="line"></span><br><span class="line">	_ <span class="keyword">uint32</span> <span class="comment">// Alignment for atomic fields below</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Per-P GC state</span></span><br><span class="line">	gcAssistTime         <span class="keyword">int64</span>    <span class="comment">// Nanoseconds in assistAlloc</span></span><br><span class="line">	gcFractionalMarkTime <span class="keyword">int64</span>    <span class="comment">// Nanoseconds in fractional mark worker (atomic)</span></span><br><span class="line">	gcBgMarkWorker       guintptr <span class="comment">// (atomic)</span></span><br><span class="line">	gcMarkWorkerMode     gcMarkWorkerMode</span><br><span class="line"></span><br><span class="line">	<span class="comment">// gcMarkWorkerStartTime is the nanotime() at which this mark</span></span><br><span class="line">	<span class="comment">// worker started.</span></span><br><span class="line">	gcMarkWorkerStartTime <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// gcw is this P's GC work buffer cache. The work buffer is</span></span><br><span class="line">	<span class="comment">// filled by write barriers, drained by mutator assists, and</span></span><br><span class="line">	<span class="comment">// disposed on certain GC state transitions.</span></span><br><span class="line">	gcw gcWork</span><br><span class="line"></span><br><span class="line">	<span class="comment">// wbBuf is this P's GC write barrier buffer.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> Consider caching this in the running G.</span></span><br><span class="line">	wbBuf wbBuf</span><br><span class="line"></span><br><span class="line">	runSafePointFn <span class="keyword">uint32</span> <span class="comment">// if 1, run sched.safePointFn at next safe point</span></span><br><span class="line"></span><br><span class="line">	pad cpu.CacheLinePad</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="2-2-4-schedt-jie-gou-ti">2.2.4 schedt结构体</span><a href="#2-2-4-schedt-jie-gou-ti" class="header-anchor">#</a></h4><p>schedt结构体用来保存调度器的状态信息和goroutine的全局运行队列</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> schedt <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// accessed atomically. keep at top to ensure alignment on 32-bit systems.</span></span><br><span class="line">    goidgen <span class="keyword">uint64</span></span><br><span class="line">    lastpoll  <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">    lock mutex</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When increasing nmidle, nmidlelocked, nmsys, or nmfreed, be</span></span><br><span class="line">    <span class="comment">// sure to call checkdead().</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由空闲的工作线程组成链表</span></span><br><span class="line">    midle       muintptr<span class="comment">// idle m's waiting for work</span></span><br><span class="line">    <span class="comment">// 空闲的工作线程的数量</span></span><br><span class="line">    nmidle      <span class="keyword">int32</span>   <span class="comment">// number of idle m's waiting for work</span></span><br><span class="line">    nmidlelockedint32   <span class="comment">// number of locked m's waiting for work</span></span><br><span class="line">    mnext       <span class="keyword">int64</span>   <span class="comment">// number of m's that have been created and next M ID</span></span><br><span class="line">    <span class="comment">// 最多只能创建maxmcount个工作线程</span></span><br><span class="line">    maxmcount   <span class="keyword">int32</span>   <span class="comment">// maximum number of m's allowed (or die)</span></span><br><span class="line">    nmsys       <span class="keyword">int32</span>   <span class="comment">// number of system m's not counted for deadlock</span></span><br><span class="line">    nmfreed     <span class="keyword">int64</span>   <span class="comment">// cumulative number of freed m's</span></span><br><span class="line"></span><br><span class="line">    ngsys <span class="keyword">uint32</span><span class="comment">// number of system goroutines; updated atomically</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由空闲的p结构体对象组成的链表</span></span><br><span class="line">    pidle     puintptr<span class="comment">// idle p's</span></span><br><span class="line">    <span class="comment">// 空闲的p结构体对象的数量</span></span><br><span class="line">    npidle    <span class="keyword">uint32</span></span><br><span class="line">    nmspinning <span class="keyword">uint32</span><span class="comment">// See "Worker thread parking/unparking" comment in proc.go.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Global runnable queue.</span></span><br><span class="line">    <span class="comment">// goroutine全局运行队列</span></span><br><span class="line">    runq    gQueue</span><br><span class="line">    runqsize <span class="keyword">int32</span></span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Global cache of dead G's.</span></span><br><span class="line">    <span class="comment">// gFree是所有已经退出的goroutine对应的g结构体对象组成的链表</span></span><br><span class="line">    <span class="comment">// 用于缓存g结构体对象，避免每次创建goroutine时都重新分配内存</span></span><br><span class="line">        gFree <span class="keyword">struct</span>&#123;</span><br><span class="line">        lock         mutex</span><br><span class="line">        stack       gList <span class="comment">// Gs with stacks</span></span><br><span class="line">        noStack   gList <span class="comment">// Gs without stacks</span></span><br><span class="line">        n             <span class="keyword">int32</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="2-2-5-qi-ta-jie-gou-ti">2.2.5 其他结构体</span><a href="#2-2-5-qi-ta-jie-gou-ti" class="header-anchor">#</a></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">allgs      []*g     <span class="comment">// 保存所有的g</span></span><br><span class="line">allm       *m       <span class="comment">// 所有的m构成的一个链表，包括下面的m0</span></span><br><span class="line">allp       []*p     <span class="comment">// 保存所有的p，len(allp) == gomaxprocs,gomaxprocs就是设置P的数量</span></span><br><span class="line"></span><br><span class="line">ncpu       <span class="keyword">int32</span>    <span class="comment">// 系统中cpu核的数量，程序启动时由runtime代码初始化</span></span><br><span class="line">gomaxprocs <span class="keyword">int32</span>    <span class="comment">// p的最大值，默认等于ncpu，但可以通过GOMAXPROCS修改</span></span><br><span class="line"></span><br><span class="line">sched      schedt   <span class="comment">// 调度器结构体对象，记录了调度器的工作状态</span></span><br><span class="line"></span><br><span class="line">m0         m        <span class="comment">// 代表进程的主线程</span></span><br><span class="line">g0         g        <span class="comment">// m0的g0，也就是m0.g0 = &amp;g0</span></span><br></pre></td></tr></table></figure>

<p>在程序初始化时，所有的变量都是对应类型的零值。所以程序刚启动时allgs，allm和allp都不包含任何g,m和p。</p>
<h2><span id="3-diao-du-ce-lue">3.调度策略</span><a href="#3-diao-du-ce-lue" class="header-anchor">#</a></h2><p>上面我们说了一大堆源码，即繁琐又看着一大堆。那么这些结构体怎么进行调度的呢？既然说到调度策略，那我们就看看调度的函数中到底发生什么？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 一轮调度，发现可运行的g并且运行.没有返回值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//  回去goroutine，返回*g </span></span><br><span class="line">    <span class="comment">// getg returns the pointer to the current g.</span></span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _g_.m.locks != <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">"schedule: holding locks"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _g_.m.lockedg != <span class="number">0</span> &#123;</span><br><span class="line">		stoplockedm()</span><br><span class="line">		execute(_g_.m.lockedg.ptr(), <span class="literal">false</span>) <span class="comment">// Never returns.</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We should not schedule away from a g that is executing a cgo call,</span></span><br><span class="line">	<span class="comment">// since the cgo call is using the m's g0 stack.</span></span><br><span class="line">	<span class="keyword">if</span> _g_.m.incgo &#123;</span><br><span class="line">		throw(<span class="string">"schedule: in cgo"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">top:</span><br><span class="line">	<span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> &#123;</span><br><span class="line">		gcstopm()</span><br><span class="line">		<span class="keyword">goto</span> top</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> _g_.m.p.ptr().runSafePointFn != <span class="number">0</span> &#123;</span><br><span class="line">		runSafePointFn()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> gp *g</span><br><span class="line">	<span class="keyword">var</span> inheritTime <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Normal goroutines will check for need to wakeP in ready,</span></span><br><span class="line">	<span class="comment">// but GCworkers and tracereaders will not, so the check must</span></span><br><span class="line">	<span class="comment">// be done here instead.</span></span><br><span class="line">	tryWakeP := <span class="literal">false</span></span><br><span class="line">	<span class="keyword">if</span> trace.enabled || trace.shutdown &#123;</span><br><span class="line">		gp = traceReader()</span><br><span class="line">		<span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">			casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">			traceGoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">			tryWakeP = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> gp == <span class="literal">nil</span> &amp;&amp; gcBlackenEnabled != <span class="number">0</span> &#123;</span><br><span class="line">		gp = gcController.findRunnableGCWorker(_g_.m.p.ptr())</span><br><span class="line">		tryWakeP = tryWakeP || gp != <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果gp是nil</span></span><br><span class="line">	<span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Check the global runnable queue once in a while to ensure fairness.</span></span><br><span class="line">		<span class="comment">// Otherwise two goroutines can completely occupy the local runqueue</span></span><br><span class="line">        <span class="comment">// by constantly respawning each other.</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 每个工作线程，每1/61的在全局运行列表中回去goroutine</span></span><br><span class="line">        <span class="comment">// 并且全局运行队列的长度必须大于0，即列表不为空</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> _g_.m.p.ptr().schedtick%<span class="number">61</span> == <span class="number">0</span> &amp;&amp; sched.runqsize &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// sched 是schedt结构对象,定义于runtime/runtime2.go的一个变量</span></span><br><span class="line">            <span class="comment">// 对于共享的全局运行列表，上锁</span></span><br><span class="line">            lock(&amp;sched.lock)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 在全局运行列表中获取1个可运行的g</span></span><br><span class="line">            gp = globrunqget(_g_.m.p.ptr(), <span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 解锁</span></span><br><span class="line">			unlock(&amp;sched.lock)</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果没有获取g，那么再去本地可运行的列表中获取</span></span><br><span class="line">	<span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">		gp, inheritTime = runqget(_g_.m.p.ptr())</span><br><span class="line">		<span class="keyword">if</span> gp != <span class="literal">nil</span> &amp;&amp; _g_.m.spinning &#123;</span><br><span class="line">			throw(<span class="string">"schedule: spinning with local work"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果从本地运行队列和全局运行队列都没有找到需要运行的goroutine，</span></span><br><span class="line">    <span class="comment">//则调用findrunnable函数从其它工作线程的运行队列中偷取，如果偷取不到，则当前工作线程会被阻塞，</span></span><br><span class="line">    <span class="comment">//直到获取到需要运行的goroutine之后findrunnable函数才会返回。</span></span><br><span class="line">    <span class="comment">// findrunnable定义中使用了标签top，实现自旋</span></span><br><span class="line">	<span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">		gp, inheritTime = findrunnable() <span class="comment">// blocks until work is available</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// This thread is going to run a goroutine and is not spinning anymore,</span></span><br><span class="line">	<span class="comment">// so if it was marked as spinning we need to reset it now and potentially</span></span><br><span class="line">	<span class="comment">// start a new spinning M.</span></span><br><span class="line">	<span class="keyword">if</span> _g_.m.spinning &#123;</span><br><span class="line">		resetspinning()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> sched.disable.user &amp;&amp; !schedEnabled(gp) &#123;</span><br><span class="line">		<span class="comment">// Scheduling of this goroutine is disabled. Put it on</span></span><br><span class="line">		<span class="comment">// the list of pending runnable goroutines for when we</span></span><br><span class="line">		<span class="comment">// re-enable user scheduling and look again.</span></span><br><span class="line">		lock(&amp;sched.lock)</span><br><span class="line">		<span class="keyword">if</span> schedEnabled(gp) &#123;</span><br><span class="line">			<span class="comment">// Something re-enabled scheduling while we</span></span><br><span class="line">			<span class="comment">// were acquiring the lock.</span></span><br><span class="line">			unlock(&amp;sched.lock)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			sched.disable.runnable.pushBack(gp)</span><br><span class="line">			sched.disable.n++</span><br><span class="line">			unlock(&amp;sched.lock)</span><br><span class="line">			<span class="keyword">goto</span> top</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If about to schedule a not-normal goroutine (a GCworker or tracereader),</span></span><br><span class="line">	<span class="comment">// wake a P if there is one.</span></span><br><span class="line">	<span class="keyword">if</span> tryWakeP &#123;</span><br><span class="line">		<span class="keyword">if</span> atomic.Load(&amp;sched.npidle) != <span class="number">0</span> &amp;&amp; atomic.Load(&amp;sched.nmspinning) == <span class="number">0</span> &#123;</span><br><span class="line">			wakep()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> gp.lockedm != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// Hands off own p to the locked m,</span></span><br><span class="line">		<span class="comment">// then blocks waiting for a new p.</span></span><br><span class="line">		startlockedm(gp)</span><br><span class="line">		<span class="keyword">goto</span> top</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	execute(gp, inheritTime)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  globrunqget 定义</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">globrunqget</span><span class="params">(_p_ *p, max <span class="keyword">int32</span>)</span> *<span class="title">g</span></span> &#123;</span><br><span class="line">    <span class="comment">// 此函数是线程非安全的，所以使用这个函数必须上锁</span></span><br><span class="line">    <span class="comment">// 全局可运行列表为空，则返回nil</span></span><br><span class="line">	<span class="keyword">if</span> sched.runqsize == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这是为了全局运行列表中的g 分配均衡</span></span><br><span class="line">    <span class="comment">// gomaxprocs 由runtime.GOMAXPROCS(）设置</span></span><br><span class="line">    <span class="comment">// 为什么＋1呢，原因很简单</span></span><br><span class="line">    <span class="comment">// 如果 sched.runqsize&lt; gomaxprocs 那么sched.runqsize/gomaxprocs==0</span></span><br><span class="line">    <span class="comment">// 所以不加1的话，那么这些g就不会被调用到</span></span><br><span class="line">    n := sched.runqsize/gomaxprocs + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  这种是为了防止sched.runqsize=2    gomaxprocs=1</span></span><br><span class="line">    <span class="comment">//  那么n为3，超过sched.runqsize</span></span><br><span class="line">	<span class="keyword">if</span> n &gt; sched.runqsize &#123;</span><br><span class="line">		n = sched.runqsize</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取多少个g，以传入的参数max为准</span></span><br><span class="line">	<span class="keyword">if</span> max &gt; <span class="number">0</span> &amp;&amp; n &gt; max &#123;</span><br><span class="line">		n = max</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> n &gt; <span class="keyword">int32</span>(<span class="built_in">len</span>(_p_.runq))/<span class="number">2</span> &#123;</span><br><span class="line">		n = <span class="keyword">int32</span>(<span class="built_in">len</span>(_p_.runq)) / <span class="number">2</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sched.runqsize -= n</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  将可运行的g，pop出全局运行列队</span></span><br><span class="line">	gp := sched.runq.pop()</span><br><span class="line">	n--</span><br><span class="line">	<span class="keyword">for</span> ; n &gt; <span class="number">0</span>; n-- &#123;</span><br><span class="line">        gp1 := sched.runq.pop()</span><br><span class="line">        <span class="comment">//  把从全局队列中获得的g放入本地队列中</span></span><br><span class="line">		runqput(_p_, gp1, <span class="literal">false</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> gp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// findrunnable的定义</span></span><br><span class="line"><span class="comment">// Finds a runnable goroutine to execute.</span></span><br><span class="line"><span class="comment">// Tries to steal from other P's, get g from global queue, poll network.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findrunnable</span><span class="params">()</span> <span class="params">(gp *g, inheritTime <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The conditions here and in handoffp must agree: if</span></span><br><span class="line">	<span class="comment">// findrunnable would return a G to run, handoffp must start</span></span><br><span class="line">	<span class="comment">// an M.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有在其他p的本地运行队列中找到，则返回top</span></span><br><span class="line">top:</span><br><span class="line">	_p_ := _g_.m.p.ptr()</span><br><span class="line">	<span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> &#123;</span><br><span class="line">		gcstopm()</span><br><span class="line">		<span class="keyword">goto</span> top</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> _p_.runSafePointFn != <span class="number">0</span> &#123;</span><br><span class="line">		runSafePointFn()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> fingwait &amp;&amp; fingwake &#123;</span><br><span class="line">		<span class="keyword">if</span> gp := wakefing(); gp != <span class="literal">nil</span> &#123;</span><br><span class="line">			ready(gp, <span class="number">0</span>, <span class="literal">true</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> *cgo_yield != <span class="literal">nil</span> &#123;</span><br><span class="line">		asmcgocall(*cgo_yield, <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在偷取其他的p的本地可运行队列中获取g之前</span></span><br><span class="line">    <span class="comment">// 优先在本地的队列中获取，如果没有的获取到g</span></span><br><span class="line">    <span class="comment">//  再去全局队列中获取</span></span><br><span class="line">	<span class="keyword">if</span> gp, inheritTime := runqget(_p_); gp != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> gp, inheritTime</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// global runq</span></span><br><span class="line">	<span class="keyword">if</span> sched.runqsize != <span class="number">0</span> &#123;</span><br><span class="line">		lock(&amp;sched.lock)</span><br><span class="line">		gp := globrunqget(_p_, <span class="number">0</span>)</span><br><span class="line">		unlock(&amp;sched.lock)</span><br><span class="line">		<span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Poll network.</span></span><br><span class="line">	<span class="comment">// This netpoll is only an optimization before we resort to stealing.</span></span><br><span class="line">	<span class="comment">// We can safely skip it if there are no waiters or a thread is blocked</span></span><br><span class="line">	<span class="comment">// in netpoll already. If there is any kind of logical race with that</span></span><br><span class="line">	<span class="comment">// blocked thread (e.g. it has already returned from netpoll, but does</span></span><br><span class="line">	<span class="comment">// not set lastpoll yet), this thread will do blocking netpoll below</span></span><br><span class="line">	<span class="comment">// anyway.</span></span><br><span class="line">	<span class="keyword">if</span> netpollinited() &amp;&amp; atomic.Load(&amp;netpollWaiters) &gt; <span class="number">0</span> &amp;&amp; atomic.Load64(&amp;sched.lastpoll) != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> list := netpoll(<span class="literal">false</span>); !list.empty() &#123; <span class="comment">// non-blocking</span></span><br><span class="line">			gp := list.pop()</span><br><span class="line">			injectglist(&amp;list)</span><br><span class="line">			casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">			<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">				traceGoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Steal work from other P's.</span></span><br><span class="line">    <span class="comment">// 如果在本地和全局列表中没有获取到g</span></span><br><span class="line">    <span class="comment">// 再去其他P的本地列表中偷取</span></span><br><span class="line">	procs := <span class="keyword">uint32</span>(gomaxprocs)</span><br><span class="line">	<span class="keyword">if</span> atomic.Load(&amp;sched.npidle) == procs<span class="number">-1</span> &#123;</span><br><span class="line">		<span class="comment">// Either GOMAXPROCS=1 or everybody, except for us, is idle already.</span></span><br><span class="line">		<span class="comment">// New work can appear from returning syscall/cgocall, network or timers.</span></span><br><span class="line">        <span class="comment">// Neither of that submits to local run queues, so no point in stealing.</span></span><br><span class="line">        </span><br><span class="line">		<span class="keyword">goto</span> stop</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// If number of spinning M's &gt;= number of busy P's, block.</span></span><br><span class="line">	<span class="comment">// This is necessary to prevent excessive CPU consumption</span></span><br><span class="line">	<span class="comment">// when GOMAXPROCS&gt;&gt;1 but the program parallelism is low.</span></span><br><span class="line">	<span class="keyword">if</span> !_g_.m.spinning &amp;&amp; <span class="number">2</span>*atomic.Load(&amp;sched.nmspinning) &gt;= procs-atomic.Load(&amp;sched.npidle) &#123;</span><br><span class="line">		<span class="keyword">goto</span> stop</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !_g_.m.spinning &#123;</span><br><span class="line">		_g_.m.spinning = <span class="literal">true</span></span><br><span class="line">		atomic.Xadd(&amp;sched.nmspinning, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> enum := stealOrder.start(fastrand()); !enum.done(); enum.next() &#123;</span><br><span class="line">			<span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">goto</span> top</span><br><span class="line">			&#125;</span><br><span class="line">			stealRunNextG := i &gt; <span class="number">2</span> <span class="comment">// first look for ready queues with more than 1 g</span></span><br><span class="line">			<span class="keyword">if</span> gp := runqsteal(_p_, allp[enum.position()], stealRunNextG); gp != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">stop:</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We have nothing to do. If we're in the GC mark phase, can</span></span><br><span class="line">	<span class="comment">// safely scan and blacken objects, and have work to do, run</span></span><br><span class="line">	<span class="comment">// idle-time marking rather than give up the P.</span></span><br><span class="line">	<span class="keyword">if</span> gcBlackenEnabled != <span class="number">0</span> &amp;&amp; _p_.gcBgMarkWorker != <span class="number">0</span> &amp;&amp; gcMarkWorkAvailable(_p_) &#123;</span><br><span class="line">		_p_.gcMarkWorkerMode = gcMarkWorkerIdleMode</span><br><span class="line">		gp := _p_.gcBgMarkWorker.ptr()</span><br><span class="line">		casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">		<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">			traceGoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// wasm only:</span></span><br><span class="line">	<span class="comment">// If a callback returned and no other goroutine is awake,</span></span><br><span class="line">	<span class="comment">// then pause execution until a callback was triggered.</span></span><br><span class="line">	<span class="keyword">if</span> beforeIdle() &#123;</span><br><span class="line">		<span class="comment">// At least one goroutine got woken.</span></span><br><span class="line">		<span class="keyword">goto</span> top</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Before we drop our P, make a snapshot of the allp slice,</span></span><br><span class="line">	<span class="comment">// which can change underfoot once we no longer block</span></span><br><span class="line">	<span class="comment">// safe-points. We don't need to snapshot the contents because</span></span><br><span class="line">	<span class="comment">// everything up to cap(allp) is immutable.</span></span><br><span class="line">	allpSnapshot := allp</span><br><span class="line"></span><br><span class="line">	<span class="comment">// return P and block</span></span><br><span class="line">	lock(&amp;sched.lock)</span><br><span class="line">	<span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> || _p_.runSafePointFn != <span class="number">0</span> &#123;</span><br><span class="line">		unlock(&amp;sched.lock)</span><br><span class="line">		<span class="keyword">goto</span> top</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> sched.runqsize != <span class="number">0</span> &#123;</span><br><span class="line">		gp := globrunqget(_p_, <span class="number">0</span>)</span><br><span class="line">		unlock(&amp;sched.lock)</span><br><span class="line">		<span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> releasep() != _p_ &#123;</span><br><span class="line">		throw(<span class="string">"findrunnable: wrong p"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	pidleput(_p_)</span><br><span class="line">	unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Delicate dance: thread transitions from spinning to non-spinning state,</span></span><br><span class="line">	<span class="comment">// potentially concurrently with submission of new goroutines. We must</span></span><br><span class="line">	<span class="comment">// drop nmspinning first and then check all per-P queues again (with</span></span><br><span class="line">	<span class="comment">// #StoreLoad memory barrier in between). If we do it the other way around,</span></span><br><span class="line">	<span class="comment">// another thread can submit a goroutine after we've checked all run queues</span></span><br><span class="line">	<span class="comment">// but before we drop nmspinning; as the result nobody will unpark a thread</span></span><br><span class="line">	<span class="comment">// to run the goroutine.</span></span><br><span class="line">	<span class="comment">// If we discover new work below, we need to restore m.spinning as a signal</span></span><br><span class="line">	<span class="comment">// for resetspinning to unpark a new worker thread (because there can be more</span></span><br><span class="line">	<span class="comment">// than one starving goroutine). However, if after discovering new work</span></span><br><span class="line">	<span class="comment">// we also observe no idle Ps, it is OK to just park the current thread:</span></span><br><span class="line">	<span class="comment">// the system is fully loaded so no spinning threads are required.</span></span><br><span class="line">	<span class="comment">// Also see "Worker thread parking/unparking" comment at the top of the file.</span></span><br><span class="line">	wasSpinning := _g_.m.spinning</span><br><span class="line">	<span class="keyword">if</span> _g_.m.spinning &#123;</span><br><span class="line">		_g_.m.spinning = <span class="literal">false</span></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">int32</span>(atomic.Xadd(&amp;sched.nmspinning, <span class="number">-1</span>)) &lt; <span class="number">0</span> &#123;</span><br><span class="line">			throw(<span class="string">"findrunnable: negative nmspinning"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// check all runqueues once again</span></span><br><span class="line">	<span class="keyword">for</span> _, _p_ := <span class="keyword">range</span> allpSnapshot &#123;</span><br><span class="line">		<span class="keyword">if</span> !runqempty(_p_) &#123;</span><br><span class="line">			lock(&amp;sched.lock)</span><br><span class="line">			_p_ = pidleget()</span><br><span class="line">			unlock(&amp;sched.lock)</span><br><span class="line">			<span class="keyword">if</span> _p_ != <span class="literal">nil</span> &#123;</span><br><span class="line">				acquirep(_p_)</span><br><span class="line">				<span class="keyword">if</span> wasSpinning &#123;</span><br><span class="line">					_g_.m.spinning = <span class="literal">true</span></span><br><span class="line">					atomic.Xadd(&amp;sched.nmspinning, <span class="number">1</span>)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">goto</span> top</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check for idle-priority GC work again.</span></span><br><span class="line">	<span class="keyword">if</span> gcBlackenEnabled != <span class="number">0</span> &amp;&amp; gcMarkWorkAvailable(<span class="literal">nil</span>) &#123;</span><br><span class="line">		lock(&amp;sched.lock)</span><br><span class="line">		_p_ = pidleget()</span><br><span class="line">		<span class="keyword">if</span> _p_ != <span class="literal">nil</span> &amp;&amp; _p_.gcBgMarkWorker == <span class="number">0</span> &#123;</span><br><span class="line">			pidleput(_p_)</span><br><span class="line">			_p_ = <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		unlock(&amp;sched.lock)</span><br><span class="line">		<span class="keyword">if</span> _p_ != <span class="literal">nil</span> &#123;</span><br><span class="line">			acquirep(_p_)</span><br><span class="line">			<span class="keyword">if</span> wasSpinning &#123;</span><br><span class="line">				_g_.m.spinning = <span class="literal">true</span></span><br><span class="line">				atomic.Xadd(&amp;sched.nmspinning, <span class="number">1</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Go back to idle GC check.</span></span><br><span class="line">			<span class="keyword">goto</span> stop</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// poll network</span></span><br><span class="line">	<span class="keyword">if</span> netpollinited() &amp;&amp; atomic.Load(&amp;netpollWaiters) &gt; <span class="number">0</span> &amp;&amp; atomic.Xchg64(&amp;sched.lastpoll, <span class="number">0</span>) != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> _g_.m.p != <span class="number">0</span> &#123;</span><br><span class="line">			throw(<span class="string">"findrunnable: netpoll with p"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> _g_.m.spinning &#123;</span><br><span class="line">			throw(<span class="string">"findrunnable: netpoll with spinning"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		list := netpoll(<span class="literal">true</span>) <span class="comment">// block until new work is available</span></span><br><span class="line">		atomic.Store64(&amp;sched.lastpoll, <span class="keyword">uint64</span>(nanotime()))</span><br><span class="line">		<span class="keyword">if</span> !list.empty() &#123;</span><br><span class="line">			lock(&amp;sched.lock)</span><br><span class="line">			_p_ = pidleget()</span><br><span class="line">			unlock(&amp;sched.lock)</span><br><span class="line">			<span class="keyword">if</span> _p_ != <span class="literal">nil</span> &#123;</span><br><span class="line">				acquirep(_p_)</span><br><span class="line">				gp := list.pop()</span><br><span class="line">				injectglist(&amp;list)</span><br><span class="line">				casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">				<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">					traceGoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line">			injectglist(&amp;list)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	stopm()</span><br><span class="line">	<span class="keyword">goto</span> top</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是源码的分析，下面对<code>schedule()</code>进行梳理：<br>注：<code>schedule()</code>是g调度的执行函数。</p>
<ul>
<li><ol>
<li>如果gp为空的时候，先从全局可运行列表中获取g。前提全局可运行列表必须不为空，并且有1/61的概率(使用mod61==0的方式)获取1个可运行的g，并保存到p的本地可运行列表中。</li>
</ol>
</li>
<li><ol start="2">
<li>如果不是1/61概率(即mod61!=0)或者没有在全局可运行队列中获取g，那么就在本地的可运行列表中进行获取。  </li>
</ol>
</li>
<li><ol start="3">
<li>如果在全局和本地可运行列表都没有获取g，则会调用<code>findrunnable()</code>函数。在执行<code>findrunnable()</code>函数时，会先检查本地和全局的列表中进行获取g。如果没有获取到g，那么会在其他的P中偷取g。如果没有获取到g，那么<code>findrunnable()</code>进入自旋状态。也就是说<code>schedule()</code>处于阻塞状态</li>
</ol>
</li>
</ul>
<h2><span id="can-kao">参考</span><a href="#can-kao" class="header-anchor">#</a></h2><ul>
<li>《go语言并发编程》</li>
<li><a href="http://morsmachine.dk/go-scheduler" target="_blank" rel="noopener">http://morsmachine.dk/go-scheduler</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/64447952" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/64447952</a>  </li>
<li><a href="https://i6448038.github.io/2017/12/04/golang-concurrency-principle/" target="_blank" rel="noopener">https://i6448038.github.io/2017/12/04/golang-concurrency-principle/</a></li>
</ul>

      </div>
      
        <br>
        


  <section class='meta' id="footer-meta">
    <div class='new-meta-box'>
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/golang/" rel="nofollow"><i class="fas fa-tag" aria-hidden="true"></i><p>golang</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/goroutine/" rel="nofollow"><i class="fas fa-tag" aria-hidden="true"></i><p>goroutine</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/调度/" rel="nofollow"><i class="fas fa-tag" aria-hidden="true"></i><p>调度</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/MPG/" rel="nofollow"><i class="fas fa-tag" aria-hidden="true"></i><p>MPG</p></a></div>


        
      
        
          

        
      
    </div>
  </section>


      
      
          <div class="prev-next">
              
                  <section class="prev">
                      <span class="art-item-left">
                          <h6><i class="fas fa-chevron-left" aria-hidden="true"></i>&nbsp;上一页</h6>
                          <h4>
                              <a href="/2019/09/25/内存对齐示例中的Sizeof函数/" rel="prev" title="内存对齐示例中的Sizeof函数">
                                
                                    内存对齐示例中的Sizeof函数
                                
                              </a>
                          </h4>
                          
                              
                              <h6 class="tags">
                                  <a class="tag" href="/tags/golang/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i> golang</a> <a class="tag" href="/tags/内存对齐/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i> 内存对齐</a> <a class="tag" href="/tags/unsafe-Sizeof/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i> unsafe.Sizeof</a>
                              </h6>
                          
                      </span>
                  </section>
              
              
                  <section class="next">
                      <span class="art-item-right" aria-hidden="true">
                          <h6>下一页&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i></h6>
                          <h4>
                              <a href="/2019/02/23/秒杀系统/" rel="prev" title="秒杀系统分析">
                                  
                                      秒杀系统分析
                                  
                              </a>
                          </h4>
                          
                              
                              <h6 class="tags">
                                  <a class="tag" href="/tags/架构/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i> 架构</a> <a class="tag" href="/tags/高并发/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i> 高并发</a> <a class="tag" href="/tags/秒杀系统/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i> 秒杀系统</a>
                              </h6>
                          
                      </span>
                  </section>
              
          </div>
      
    </section>
  </article>



  <!-- 显示推荐文章和评论 -->



  






<!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->



  <script>
    window.subData = {
      title: 'golang之goroutine调度',
      tools: true
    }
  </script>


</div>
<aside class='l_side'>
  
    
    
      
      
        
          
          
            
              <section class='widget author'>
  <div class='content pure'>
    
      <div class='avatar'>
        <img class='avatar' src='http://pzklm3h5m.bkt.clouddn.com/timg.jpeg'/>
      </div>
    
    
    
      <div class="social-wrapper">
        
          
            <a href="/"
              class="social fas fa-rss flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="mailto:tylitianrui@126.com"
              class="social fas fa-envelope flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://github.com/tylitianrui"
              class="social fab fa-github flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
      </div>
    
  </div>
</section>

            
          
        
          
          
        
          
          
        
          
          
        
          
          
        
      
        
          
          
        
          
          
            
              
  <section class='widget toc-wrapper'>
    
<header class='pure'>
  <div><i class="fas fa-list fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;本文目录</div>
  
    <!-- <div class='wrapper'><a class="s-toc rightBtn" rel="external nofollow noopener noreferrer" href="javascript:void(0)"><i class="fas fa-thumbtack fa-fw"></i></a></div> -->
  
</header>

    <div class='content pure'>
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#null"><span class="toc-text">1.调度模型#</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#null"><span class="toc-text">1.1 内核级线程模型#</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null"><span class="toc-text">1.2 用户级线程模型#</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null"><span class="toc-text">1.3 两级线程模型#</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#null"><span class="toc-text">2.MPG模型#</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#null"><span class="toc-text">2.1 简述#</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null"><span class="toc-text">2.2 源码分析#</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#null"><span class="toc-text">2.2.1 g结构体#</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#null"><span class="toc-text">2.2.2 m结构体#</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#null"><span class="toc-text">2.2.3 p结构体#</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#null"><span class="toc-text">2.2.4 schedt结构体#</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#null"><span class="toc-text">2.2.5 其他结构体#</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#null"><span class="toc-text">3.调度策略#</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#null"><span class="toc-text">参考#</span></a></li></ol>
    </div>
  </section>


            
          
        
          
          
        
          
          
        
          
          
        
      
        
          
          
        
          
          
        
          
          
            
              <section class='widget grid'>
  
<header class='pure'>
  <div><i class="fas fa-map-signs fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;站内导航</div>
  
</header>

  <div class='content pure'>
    <ul class="grid navgation">
      
        <li><a class="flat-box" title="/" href="/"
          
          
          id="home">
          
            <i class="fas fa-clock fa-fw" aria-hidden="true"></i>
          
          近期文章
        </a></li>
      
        <li><a class="flat-box" title="/archives" href="/archives"
          
            rel="nofollow"
          
          
          id="archives">
          
            <i class="fas fa-archive fa-fw" aria-hidden="true"></i>
          
          文章归档
        </a></li>
      
        <li><a class="flat-box" title="/about/" href="/about/"
          
            rel="nofollow"
          
          
          id="about">
          
            <i class="fas fa-info-circle fa-fw" aria-hidden="true"></i>
          
          关于我
        </a></li>
      
    </ul>
  </div>
</section>

            
          
        
          
          
        
          
          
        
      
        
          
          
        
          
          
        
          
          
        
          
          
            
              
  <section class='widget category'>
    
<header class='pure'>
  <div><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;文章分类</div>
  
    <a class="rightBtn"
    
      rel="nofollow"
    
    
    href="/"
    title="/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class='content pure'>
      <ul class="entry">
        
          <li><a class="flat-box" title="/categories/MySQL/" href="/categories/MySQL/"><div class='name'>MySQL</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Redis/" href="/categories/Redis/"><div class='name'>Redis</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/golang/" href="/categories/golang/"><div class='name'>golang</div><div class='badge'>(7)</div></a></li>
        
          <li><a class="flat-box" title="/categories/nginx/" href="/categories/nginx/"><div class='name'>nginx</div><div class='badge'>(4)</div></a></li>
        
          <li><a class="flat-box" title="/categories/openresty/" href="/categories/openresty/"><div class='name'>openresty</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/python/" href="/categories/python/"><div class='name'>python</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box" title="/categories/个人总结/" href="/categories/个人总结/"><div class='name'>个人总结</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/数据结构与算法/" href="/categories/数据结构与算法/"><div class='name'>数据结构与算法</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box" title="/categories/杂谈/" href="/categories/杂谈/"><div class='name'>杂谈</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/架构/" href="/categories/架构/"><div class='name'>架构</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box" title="/categories/经验分享/" href="/categories/经验分享/"><div class='name'>经验分享</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box" title="/categories/网络/" href="/categories/网络/"><div class='name'>网络</div><div class='badge'>(1)</div></a></li>
        
      </ul>
    </div>
  </section>


            
          
        
          
          
        
      
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
            
              
  <section class='widget tagcloud'>
    
<header class='pure'>
  <div><i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;热门标签</div>
  
    <a class="rightBtn"
    
      rel="nofollow"
    
    
    href="/"
    title="/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class='content pure'>
      <a href="/tags/GC/" style="font-size: 16px; color: #8b8b8b">GC</a> <a href="/tags/InnoDB/" style="font-size: 14px; color: #999">InnoDB</a> <a href="/tags/MPG/" style="font-size: 14px; color: #999">MPG</a> <a href="/tags/MySQL/" style="font-size: 14px; color: #999">MySQL</a> <a href="/tags/TCP/" style="font-size: 14px; color: #999">TCP</a> <a href="/tags/change-buffer/" style="font-size: 14px; color: #999">change buffer</a> <a href="/tags/channel源码/" style="font-size: 14px; color: #999">channel源码</a> <a href="/tags/defer/" style="font-size: 14px; color: #999">defer</a> <a href="/tags/golang/" style="font-size: 22px; color: #636363">golang</a> <a href="/tags/goroutine/" style="font-size: 14px; color: #999">goroutine</a> <a href="/tags/go源码分析/" style="font-size: 16px; color: #8b8b8b">go源码分析</a> <a href="/tags/go调优/" style="font-size: 14px; color: #999">go调优</a> <a href="/tags/innodb/" style="font-size: 14px; color: #999">innodb</a> <a href="/tags/leecode/" style="font-size: 14px; color: #999">leecode</a> <a href="/tags/map源码/" style="font-size: 14px; color: #999">map源码</a> <a href="/tags/mysql/" style="font-size: 14px; color: #999">mysql</a> <a href="/tags/nginx/" style="font-size: 18px; color: #7e7e7e">nginx</a> <a href="/tags/nginx-lua/" style="font-size: 14px; color: #999">nginx+lua</a> <a href="/tags/nginx-conf/" style="font-size: 16px; color: #8b8b8b">nginx.conf</a> <a href="/tags/nginx优化/" style="font-size: 14px; color: #999">nginx优化</a> <a href="/tags/nginx实战总结/" style="font-size: 20px; color: #707070">nginx实战总结</a> <a href="/tags/openresty/" style="font-size: 14px; color: #999">openresty</a> <a href="/tags/post的幂等性/" style="font-size: 14px; color: #999">post的幂等性</a> <a href="/tags/python/" style="font-size: 18px; color: #7e7e7e">python</a> <a href="/tags/redis/" style="font-size: 14px; color: #999">redis</a> <a href="/tags/socket/" style="font-size: 14px; color: #999">socket</a> <a href="/tags/unsafe-Sizeof/" style="font-size: 14px; color: #999">unsafe.Sizeof</a> <a href="/tags/xorm-reverse/" style="font-size: 14px; color: #999">xorm reverse</a> <a href="/tags/位运算/" style="font-size: 14px; color: #999">位运算</a> <a href="/tags/内存对齐/" style="font-size: 14px; color: #999">内存对齐</a> <a href="/tags/内存管理/" style="font-size: 16px; color: #8b8b8b">内存管理</a> <a href="/tags/刷题/" style="font-size: 14px; color: #999">刷题</a> <a href="/tags/剑指offer/" style="font-size: 14px; color: #999">剑指offer</a> <a href="/tags/垃圾回收/" style="font-size: 14px; color: #999">垃圾回收</a> <a href="/tags/奇技淫巧/" style="font-size: 14px; color: #999">奇技淫巧</a> <a href="/tags/平滑升级/" style="font-size: 14px; color: #999">平滑升级</a> <a href="/tags/开始/" style="font-size: 14px; color: #999">开始</a> <a href="/tags/技巧/" style="font-size: 14px; color: #999">技巧</a> <a href="/tags/数据结构/" style="font-size: 14px; color: #999">数据结构</a> <a href="/tags/有序链表/" style="font-size: 14px; color: #999">有序链表</a> <a href="/tags/架构/" style="font-size: 24px; color: #555">架构</a> <a href="/tags/秒杀系统/" style="font-size: 16px; color: #8b8b8b">秒杀系统</a> <a href="/tags/算法/" style="font-size: 14px; color: #999">算法</a> <a href="/tags/缓存中的“坑”/" style="font-size: 16px; color: #8b8b8b">缓存中的“坑”</a> <a href="/tags/缓存击穿/" style="font-size: 14px; color: #999">缓存击穿</a> <a href="/tags/缓存穿透/" style="font-size: 14px; color: #999">缓存穿透</a> <a href="/tags/网络/" style="font-size: 14px; color: #999">网络</a> <a href="/tags/自适应哈希索引/" style="font-size: 14px; color: #999">自适应哈希索引</a> <a href="/tags/装饰器/" style="font-size: 14px; color: #999">装饰器</a> <a href="/tags/解析缓存/" style="font-size: 14px; color: #999">解析缓存</a> <a href="/tags/订单重复提交/" style="font-size: 14px; color: #999">订单重复提交</a> <a href="/tags/记忆/" style="font-size: 14px; color: #999">记忆</a> <a href="/tags/调度/" style="font-size: 14px; color: #999">调度</a> <a href="/tags/负载均衡/" style="font-size: 14px; color: #999">负载均衡</a> <a href="/tags/超卖/" style="font-size: 14px; color: #999">超卖</a> <a href="/tags/跳跃表/" style="font-size: 14px; color: #999">跳跃表</a> <a href="/tags/配置文件/" style="font-size: 16px; color: #8b8b8b">配置文件</a> <a href="/tags/高并发/" style="font-size: 16px; color: #8b8b8b">高并发</a>
    </div>
  </section>


            
          
        
      
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
      
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
      
    

  
</aside>

<footer id="footer" class="clearfix">
  
  
    <div class="social-wrapper">
      
        
          <a href="/"
            class="social fas fa-rss flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="mailto:tylitianrui@126.com"
            class="social fas fa-envelope flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="https://github.com/tylitianrui"
            class="social fab fa-github flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
    </div>
  
  <br>
  <div><p>power by <a href="https://hexo.io/">HEXO</a> </p>
</div>
  <div>
    本站使用
    <a href="https://xaoxuu.com/wiki/material-x/" target="_blank" class="codename">Material X</a>
    作为主题
    
      ，
      总访问量为
      <span id="busuanzi_value_site_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span>
      次
    
    。
  </div>
</footer>
<script>setLoadingBarProgress(80);</script>


      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>

<script src="//instant.page/1.2.2" type="module" integrity="sha384-2xV8M5griQmzyiY3CDqh1dn4z3llDVqZDqzjzcY+jCBCk/a5fXJmuZ/40JJAPeoU"></script>


  <script async src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.5/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      const $reveal = $('.reveal');
      if ($reveal.length === 0) return;
      const sr = ScrollReveal({ distance: 0 });
      sr.reveal('.reveal');
    });
  </script>


  <script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>
  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>




  
  
  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-backstretch/2.0.4/jquery.backstretch.min.js"></script>
    <script type="text/javascript">
      $(function(){
        if ('.cover') {
          $('.cover').backstretch(
          ["http://pzklm3h5m.bkt.clouddn.com/91197b04c13f512f734a76d4ac422d89dbe229.jpg"],
          {
            duration: "6000",
            fade: "2500"
          });
        } else {
          $.backstretch(
          ["http://pzklm3h5m.bkt.clouddn.com/91197b04c13f512f734a76d4ac422d89dbe229.jpg"],
          {
            duration: "6000",
            fade: "2500"
          });
        }
      });
    </script>
  











  <script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.9/js/app.js"></script>


  <script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.9/js/search.js"></script>




<!-- 复制 -->
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  let COPY_SUCCESS = "复制成功";
  let COPY_FAILURE = "复制失败";
  /*页面载入完成后，创建复制按钮*/
  !function (e, t, a) {
    /* code */
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '  <i class="fa fa-copy"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });

      clipboard.on('success', function(e) {
        //您可以加入成功提示
        console.info('Action:', e.action);
        console.info('Text:', e.text);
        console.info('Trigger:', e.trigger);
        success_prompt(COPY_SUCCESS);
        e.clearSelection();
      });
      clipboard.on('error', function(e) {
        //您可以加入失败提示
        console.error('Action:', e.action);
        console.error('Trigger:', e.trigger);
        fail_prompt(COPY_FAILURE);
      });
    }
    initCopyCode();

  }(window, document);

  /**
   * 弹出式提示框，默认1.5秒自动消失
   * @param message 提示信息
   * @param style 提示样式，有alert-success、alert-danger、alert-warning、alert-info
   * @param time 消失时间
   */
  var prompt = function (message, style, time)
  {
      style = (style === undefined) ? 'alert-success' : style;
      time = (time === undefined) ? 1500 : time*1000;
      $('<div>')
          .appendTo('body')
          .addClass('alert ' + style)
          .html(message)
          .show()
          .delay(time)
          .fadeOut();
  };

  // 成功提示
  var success_prompt = function(message, time)
  {
      prompt(message, 'alert-success', time);
  };

  // 失败提示
  var fail_prompt = function(message, time)
  {
      prompt(message, 'alert-danger', time);
  };

  // 提醒
  var warning_prompt = function(message, time)
  {
      prompt(message, 'alert-warning', time);
  };

  // 信息提示
  var info_prompt = function(message, time)
  {
      prompt(message, 'alert-info', time);
  };

</script>


<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  let LAZY_LOAD_IMAGE = "";
  $(".article-entry").find("fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });
</script>





  <script>setLoadingBarProgress(100);</script>
</body>
</html>
